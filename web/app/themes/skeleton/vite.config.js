// import { resolve as resolvePath } from 'path';

import { defineConfig } from 'vite';
import { rm, mkdir, writeFile } from 'node:fs/promises'
// import { resolve } from 'path'
// import { CopyFilePlugin } from './plugins';

const __dirname = new URL('.', import.meta.url).pathname;
const getEntries = (entries) => { const out = {}; entries.forEach(entry => { out[entry.name] = entry.source; }); return out; };
// const getEntries = (entries) => entries.map(entry => entry.source);

const entries = [
	{ name: 'main', source: './src/js/main.js', },
	{ name: 'admin', source: './src/js/admin.js', },
	{ name: 'main-css', source: './src/scss/main-css.js', },
	{ name: 'admin-css', source: './src/scss/admin-css.js', },
];



// const distDir = resolve(__dirname, 'dist');
const distDir = './dist';
// const distDir = '../dist';
const assetsDir = 'assets';
console.log(__dirname)

export default defineConfig({
	plugins: [
		// ...entries.map(entry => CopyFilePlugin({
		// 	sourceFileName: entry.type === 'css' ? `${entry.name}.css` : entry.name,
		// 	absolutePathToDestination: resolvePath(__dirname, '../dist/assets'),
		// 	// absolutePathToDestination: entry.type === 'css'
		// 	// 	? resolvePath(__dirname, '../dist/assets')
		// 	// 	: resolvePath(__dirname, '../dist/assets'),
		// })),
		// {
		// 	name: "Cleaning theme folder",
		// 	async buildStart() {
		// 		await rm(distDir + '/assets/js', { recursive: true, force: true });
		// 		await rm(distDir + '/assets/css', { recursive: true, force: true });
		// 		await mkdir(distDir + '/assets/js', { recursive: true });
		// 		await mkdir(distDir + '/assets/css', { recursive: true });
		// 	}
		// },
		{
			name: "Create Manifest",
			writeBundle: async (data, output) => {
				console.log({output})
				// return;
				// // console.log("creating manifest", {data});
				// console.log("creating manifest", Object.entries(output).map(([key, out]) => {
				// 	return {
				// 		key: key,
				// 		meta: out?.viteMetadata,
				// 	}
				// }));

				const cssEntryFiles = Object.keys(output).length
					? Object
						.entries(output)
						.filter(([key, entry]) => entry.viteMetadata?.importedCss?.size)
						.map(([key, entry]) => {

							const generated = [];
							entry.viteMetadata.importedCss.forEach(input => {
								generated.push(input);
							})

							return {
								key: key,
								name: entry.name,
								generated: generated,
								// inputs: Array.from(entry.viteMetadata.importedCss.entries()),
							}
						})
					: []

				/**
				 * consider whether we should be cross-referencing the entry in $output with
				 * the entries available in $entries
				 */
				const manifest = {};
				for (const entry of Object.values(output)) {
					// console.log({entry})
					const {name, fileName} = entry;


					const isCssEntrypoint = entry.viteMetadata?.importedCss?.size;
					if (isCssEntrypoint) {
						// skip output of JS file in manifest
						continue;
					}

					const cssEntryFileMeta = cssEntryFiles.find(file => file.generated.includes(fileName));
					const entryName = cssEntryFileMeta?.name || name; // override the <name>.css name generated by Rollup (when applicable)

					let filenameFixedPath = fileName.startsWith(assetsDir)
						? fileName.replace(assetsDir, '/dist/assets')
						: fileName;


					const cssEntryFile = output[cssEntryFileMeta?.key]; // JS file that imports the scss

					let sourceFile;
					if (cssEntryFile) {
						const modulesKeys = Object.keys(cssEntryFile.modules);
						if (modulesKeys?.length) {
							sourceFile = getFilenameFromPath(modulesKeys[0]);
						}
					}
					else {
						sourceFile = getFilenameFromPath(entry.facadeModuleId);
					}
					// /**
					//  * For CSS files we need to get their JS entry file
					//  */
					// const sourceFileSegments = cssEntryFile
					// 	? cssEntryFile.facadeModuleId?.split('/')
					// 	: entry.facadeModuleId?.split('/');

					// // let sourceFile = sourceFileSegments?.length
					// // 	? sourceFileSegments[sourceFileSegments.length - 1]
					// // 	: '';

					manifest[entryName] = {
						handle: entryName,
						fileName: filenameFixedPath,
						source: sourceFile,
					}
				}

				const jsonData = JSON.stringify(manifest);
				await rm(distDir + '/manifest.json', { force: true });
				await writeFile(distDir + '/manifest.json', jsonData);


				/**
				 * Remove empty JS files generated from CSS/SCSS entry files.
				 *
				 * Note: we do this here rather than in the generateBundle hook because otherwise
				 * we can't get the name of the original entry file
				 */
				if (cssEntryFiles.length) {
					for (const file of cssEntryFiles) {
						const path = distDir + '/' + file.key;
						await rm(path);
					}
				}
			}
		},
		{
			name: "Skip hot-reloading JS",
			apply: 'serve',
			handleHotUpdate: (ctx) => {
				/**
				 * There are some issues with the websocket not reconnecting
				 * after a JS update/reload, so for the moment we will only
				 * hot-reload SCSS changes.
				 *
				 * Note: It looks like .scss files have a type === 'js', so we can't
				 * use that to distinguish js/scss files
				 */
				// return ctx.modules.filter(m => m.type !== 'js');
				return ctx.modules.filter(m => !m.file.endsWith('.js'));
			},
		},
		{
			name: "Reload on JS or PHP changes",
			apply: 'serve',
			configureServer: (server) => {
				const {watcher, ws} = server;

				function maybeReload(path) {
					const isPhp = path.endsWith('.php');
					const isJs = path.endsWith('.js');
					const delay = 100; // this _may_ not be necessary

					if (isPhp || isJs) {
						setTimeout(() => {
							ws.send({
								type: 'full-reload',
								path: '*',
							});
						}, delay);
					}
				}

				watcher.on('add', maybeReload);
				watcher.on('change', maybeReload);
			},
		},
	],
	build: {
		target: 'modules',
		outDir: 'dist',
		// outDir: '../dist',
		assetsDir: assetsDir,
		rollupOptions: { input: getEntries(entries) },
		// manifest: true,
	},
	server: {
		port: 3000,
		host: '0.0.0.0',
	},
	// root: './src/',
	publicDir: './src/public',
});

/**
 * Very simple and naieve implementation. Do not use outside this file
 *
 *
 * @param string path
 */
function getFilenameFromPath(path) {

	const segments = path?.split('/');
	if (!segments?.length) return '';

	return segments[segments.length - 1]
}
